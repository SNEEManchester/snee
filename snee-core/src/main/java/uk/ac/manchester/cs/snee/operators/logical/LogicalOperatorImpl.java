/****************************************************************************\ 
 *                                                                            *
 *  SNEE (Sensor NEtwork Engine)                                              *
 *  http://code.google.com/p/snee                                             *
 *  Release 1.0, 24 May 2009, under New BSD License.                          *
 *                                                                            *
 *  Copyright (c) 2009, University of Manchester                              *
 *  All rights reserved.                                                      *
 *                                                                            *
 *  Redistribution and use in source and binary forms, with or without        *
 *  modification, are permitted provided that the following conditions are    *
 *  met: Redistributions of source code must retain the above copyright       *
 *  notice, this list of conditions and the following disclaimer.             *
 *  Redistributions in binary form must reproduce the above copyright notice, *
 *  this list of conditions and the following disclaimer in the documentation *
 *  and/or other materials provided with the distribution.                    *
 *  Neither the name of the University of Manchester nor the names of its     *
 *  contributors may be used to endorse or promote products derived from this *
 *  software without specific prior written permission.                       *
 *                                                                            *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS   *
 *  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, *
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR    *
 *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR          *
 *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,     *
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,       *
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR        *
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF    *
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING      *
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS        *
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.              *
 *                                                                            *
\****************************************************************************/ 
package uk.ac.manchester.cs.snee.operators.logical;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Logger;

import uk.ac.manchester.cs.snee.SNEECompilerException;
import uk.ac.manchester.cs.snee.common.Utils;
import uk.ac.manchester.cs.snee.common.graph.NodeImplementation;
import uk.ac.manchester.cs.snee.compiler.queryplan.expressions.Attribute;
import uk.ac.manchester.cs.snee.compiler.queryplan.expressions.Expression;
import uk.ac.manchester.cs.snee.compiler.queryplan.expressions.NoPredicate;
import uk.ac.manchester.cs.snee.metadata.schema.AttributeType;
import uk.ac.manchester.cs.snee.metadata.schema.SchemaMetadataException;
import uk.ac.manchester.cs.snee.metadata.schema.TypeMappingException;
import uk.ac.manchester.cs.snee.metadata.source.SourceType;


/**
 * Base class for all logical operators. Specific operators
 * extend this class.
 */
public abstract class LogicalOperatorImpl extends NodeImplementation
implements LogicalOperator {

	/**
	 * See java.util.logging.Logger.
	 */
	private Logger logger = 
		Logger.getLogger(LogicalOperatorImpl.class.getName());

	/**
	 * The name of the operator, e.g., ACQUIRE, JOIN.
	 */
	private String operatorName;
	
	/**
	 * Id to be given to the next Operator to be created.
	 */
	private static int opCount = 0;

	/**
	 * The output data type of the operator,
	 *  e.g., ALLTUPLES, RELATION, STREAM or WINDOW.
	 */
	private OperatorDataType operatorDataType;

	/** 
	 * Predicate that this operator is expected to test data against.
	 */
	private Expression predicate = new NoPredicate();

	protected AttributeType _boolType;
	
	private SourceType operatorSourceType;
	
	/**
	 * This variable holds the rate at which data 
	 * is generated by the operator
	 */
	double sourceRate;
	
	/**
	 * This variable is used to hold the property of the operator
	 * which tells, if this instance of the operator should <i>pull<i>
	 * the next data from the child operator using a getNext()
	 * method call, or whether it should stick to the <i>subscribe<i>
	 * mode, where the data flow is driven by the update method
	 */
	private boolean isGetDataByPullModeOperator = false;
	
	private boolean isPushBasedOperator = true;

	/**
	 * Constructs a new operator. 
	 */
	public LogicalOperatorImpl(AttributeType boolType) {
		/* Assign the operator an automatic ID */
		super(getNextID());
		_boolType = boolType;    
	}

	public static String getNextID() {
		opCount++;
		return new Integer(opCount).toString();
	}


	//XXX: where do we actually use this constructor?
//	/**
//	 * Makes a clone of the operator without using a new opCount.
//	 * @param model Operator to get internal data from.
//	 */
//	protected LogicalOperatorImpl(LogicalOperator model) {
//		super(model);
//		this.operatorDataType = model.getOperatorDataType();
//		this.operatorName = model.getOperatorName();
//		this.paramStr = model.getParamStr();
//		this.predicate = model.getPredicate();
//	}
	
	//XXX: where do we actually use this constructor?
//	/**
//	 * Makes a copy of the operator using a new opCount.
//	 * @param model Operator to get internal data from.
//	 * @param newID boolean flag expected to be true. 
//	 */
//	protected LogicalOperatorImpl(LogicalOperator model, boolean newID) {
//		super(new Integer(opCount).toString());
//		opCount++;        
//		assert (newID);
//		this.operatorDataType = model.getOperatorDataType();
//		this.operatorSourceType = model.getOperatorSourceType();
//		this.operatorName = model.getOperatorName();
//		this.paramStr = model.getParamStr();
//		this.predicate = model.getPredicate();
//	}

	/**
	 * @return The output operator at index 0.
	 */
	public LogicalOperator getParent() {
		return (LogicalOperator) this.getOutput(0);
	}
	
	public void setOperatorName(String newName) {
		this.operatorName = newName;
	}
	
	public String getOperatorName() {
		return this.operatorName;
	}
	
	/**
	 * Constructs a new operator, building tree from leaves upwards.
	 * 
	 * @param children The children of an operator
	 */
	// TODO: Change children to arrayList type?
	protected void setChildren(LogicalOperator[] children) {
		if (logger.isTraceEnabled())
			logger.trace("ENTER setChildren() #children=" + children.length);
		for (LogicalOperator element : children) {
			this.addInput(element);
			element.addOutput(this);
		}

		//		//for now, but probably oversimplifying
		//		if (children.length > 0) {
		//			this.partitioningAttribute = children[0].getPartitioningAttribute();
		//		} else {
		//			throw new AssertionError("Unexpected point reached.");
		//		}
		if (logger.isTraceEnabled())
			logger.trace("ENTER setChildren()");
	}

	//CB: Used by logicalOptimiser
	/**
	 * Returns the input operator at the index
	 * specified.
	 * @param index Position of the operator to be returned.
	 * @return The child operator with this index.
	 */
	public LogicalOperator getInput(int index) {
		return (LogicalOperator) super.getInput(index);
	}

	/** 
	 * Gets the operator to which this operator send data.
	 * @param index Position of the operator to be returned.
	 * @return The parent operator with this index.
	 */
	public LogicalOperator getOutput(int index) {
		return (LogicalOperator) super.getOutput(index);
	}


	/**
	 * Returns a String representation of the operator. This is used
	 * for debugging.
	 * 
	 * @return A string representation of the operator including its children.
	 */
	public abstract String toString();


	/**
	 * Gets a description of this operator only.
	 * CB: Used by TreeDisplay and toString for debugging
	 * 
	 * @return A string representation of this operator but not its children
	 */
	public String getText() {
		StringBuffer s = new StringBuffer();
		s.append("TYPE: ");
		s.append(this.getOperatorDataType());
		s.append("   OPERATOR: ");
		s.append(this.getOperatorName());
		if (this.getParamStr() != null) {
			s.append(" (");
			s.append(this.getParamStr());
			s.append(" )");
		}
		s.append(" - cardinality: ");
		s.append(new Long(this.getCardinality(CardinalityType.MAX)).toString());
//		s.append("\n");
		return s.toString();
	}

	/**
	 * Iterator to traverse the immediate children of the current operator.
	 * @return An iterator over the children
	 */
	public Iterator<LogicalOperator> childOperatorIterator() {

		List<LogicalOperator> opList = new ArrayList<LogicalOperator>();

		for (int n = 0; n < this.getInDegree(); n++) {
			LogicalOperator op = this.getInput(n);
			opList.add(op);
		}

		return opList.iterator();
	}    

	/** {@inheritDoc} */
	public OperatorDataType getOperatorDataType() {
		assert (operatorDataType != null);
		return this.operatorDataType;
	}

	/**
	 * @param newOperatorDataType New value.
	 */
	protected void setOperatorDataType(
			OperatorDataType newOperatorDataType) {
		if (logger.isTraceEnabled()) {
			logger.trace("ENTER setOperatorDataType() with " +
					newOperatorDataType);
		}
		assert (newOperatorDataType != null);
		this.operatorDataType = newOperatorDataType;
		if (logger.isTraceEnabled()) {
			logger.trace("RETURN setOperatorDataType()");
		}
	}

	/** {@inheritDoc} 
	 * @throws SchemaMetadataException 
	 * @throws TypeMappingException */    
	public String getTupleAttributesStr(int maxPerLine) 
	throws SchemaMetadataException, TypeMappingException {
		List<Attribute> attributes = getAttributes();

		StringBuffer strBuff = new StringBuffer();
		strBuff.append("(");
		for (int i = 0; i < attributes.size(); i++) {
			//commas
			if (i > 0) {
				strBuff.append(", ");
				if ((i % maxPerLine == 0) && (i - 1) < attributes.size()) {  
					strBuff.append("\\n");
				}
			}
			strBuff.append(attributes.get(i));
			strBuff.append(":");
			assert (attributes.get(i) != null);
			assert (attributes.get(i).getType() != null);            
			strBuff.append(Utils.capFirstLetter(
					attributes.get(i).getType().getName()));

		}
		strBuff.append(")");
		return strBuff.toString();
	}


	/** 
	 * List of the attribute returned by this operator.
	 * 
	 * @return List of the returned attributes.
	 */
	public List<Attribute> defaultGetAttributes() {
		return (this.getInput(0)).getAttributes();		
	}

	/** {@inheritDoc} */    
	public List<Expression> defaultGetExpressions() {
		List<Expression> expressions = new ArrayList<Expression>(); 
		expressions.addAll(getAttributes());
		return expressions;
	}

	/** {@inheritDoc} */ 
	public String getParamStr() {
		return getPredicate().toString();
	}

	/** {@inheritDoc} */    
	public Expression getPredicate() {
		return predicate;
	}

	/** {@inheritDoc} 
	 * @throws AssertionError 
	 * @throws SchemaMetadataException 
	 * @throws TypeMappingException */    
	public void setPredicate(Expression newPredicate) 
	throws SchemaMetadataException, AssertionError, TypeMappingException 
	{
		if (logger.isDebugEnabled())
			logger.debug("ENTER setPredicate() with " + newPredicate);
		if (newPredicate instanceof NoPredicate) {
			if (logger.isTraceEnabled())
				logger.trace("Instance of NoPredicate");
			this.predicate = newPredicate;
			if (logger.isDebugEnabled())
				logger.debug("RETURN setPredicate()");
			return;
		}
		if (logger.isTraceEnabled())
			logger.trace("Predicate expression type: " + 
					newPredicate.getType() + 
					"\n\t\t\tBoolean type: " + _boolType);
		if (newPredicate.getType() != _boolType) {
			String msg = "Illegal attempt to use a none boolean " +
			"expression as a predicate.";
			logger.warn(msg);
			throw new AssertionError(msg);
		}
		if (this.acceptsPredicates()) {
			this.predicate = newPredicate;
		} else {
			String msg = "Illegal call.";
			logger.warn(msg);
			throw new AssertionError(msg);
		}
		if (logger.isDebugEnabled())
			logger.debug("RETURN setPredicate()");
	}
	
	/** {@inheritDoc} */
	public SourceType getOperatorSourceType() {
		assert (operatorSourceType != null);
		return this.operatorSourceType;
	}

	/**
	 * @param newOperatorDataType New value.
	 */
	protected void setOperatorSourceType(
			SourceType sourceType) {
		if (logger.isTraceEnabled()) {
			logger.trace("ENTER setOperatorSourceType() with " +
					sourceType);
		}
		assert (sourceType != null);
		this.operatorSourceType = sourceType;
		if (logger.isTraceEnabled()) {
			logger.trace("RETURN setOperatorSourceType()");
		}
	}
	
	/**
	 * This method finds the source type of the join operator
	 * based on its left and right child inputs.
	 * 
	 * @param left
	 * @param right
	 * @return
	 * @throws SNEECompilerException 
	 */
	protected SourceType getOperatorSourceType(LogicalOperator left, LogicalOperator right) 
	throws SNEECompilerException {
		if (logger.isTraceEnabled()) {
			logger.trace("ENTER getOperatorSourceType()" +
					"\n\tleft " + left + 
					"\n\tright " + right);
		}
		SourceType returnSourceType = null;
		LogicalOperator higherPrecedenceOp = getHigherPrecedenceOp(left, right);
		returnSourceType = higherPrecedenceOp.getOperatorSourceType();
		if (logger.isTraceEnabled()) {
			logger.trace("RETURN getOperatorSourceType() with " + 
					returnSourceType);
		}
		return returnSourceType;
	}
	
	/**
	 * This method chooses the operator that has the higher precedence
	 * where Pushed>Pulled>Scanned
	 * 
	 * @param left
	 * @param right
	 * @return
	 * @throws SNEECompilerException 
	 */
	private LogicalOperator getHigherPrecedenceOp(LogicalOperator left, LogicalOperator right) 
	throws SNEECompilerException {
		if (logger.isTraceEnabled()) {
			logger.trace("ENTER getHigherPrecedenceOp() " +
					"\n\tleft: " + left + "\n\tright: " + right);
		}
		LogicalOperator returnOperator = null;;
		SourceType lSourceType = left.getOperatorSourceType();
		SourceType rSourceType = right.getOperatorSourceType();
		if (logger.isTraceEnabled()) {
			logger.trace("Left source type: " + lSourceType);
			logger.trace("Right source type: " + rSourceType);
		}
		if (lSourceType == rSourceType) {
			//returnSourceType = lSourceType;
			returnOperator = left;
		} else if ((lSourceType == SourceType.SENSOR_NETWORK)
				&& (rSourceType == SourceType.PULL_STREAM_SERVICE
						|| rSourceType == SourceType.UDP_SOURCE 
						|| rSourceType == SourceType.PUSH_STREAM_SERVICE)) {
			//returnSourceType = rSourceType;
			returnOperator = right;
		} else if ((lSourceType == SourceType.PULL_STREAM_SERVICE
				|| lSourceType == SourceType.UDP_SOURCE 
				|| lSourceType == SourceType.PUSH_STREAM_SERVICE) 
				&& (rSourceType == SourceType.SENSOR_NETWORK)) {
			//returnSourceType = lSourceType;
			returnOperator = left;
		} else if ((lSourceType == SourceType.SENSOR_NETWORK)
				&& (rSourceType == SourceType.RELATIONAL || rSourceType == SourceType.WSDAIR)) {
			//returnSourceType = lSourceType;
			returnOperator = left;
		} else if ((rSourceType == SourceType.SENSOR_NETWORK)
				&& (lSourceType == SourceType.RELATIONAL || rSourceType == SourceType.WSDAIR)) {
			//returnSourceType = rSourType;
			returnOperator = right;
		} else if ((lSourceType == SourceType.PULL_STREAM_SERVICE
				|| lSourceType == SourceType.UDP_SOURCE 
				|| lSourceType == SourceType.PUSH_STREAM_SERVICE)
				&& (rSourceType == SourceType.RELATIONAL || rSourceType == SourceType.WSDAIR)) {
			//returnSourceType = rSourceType;
			returnOperator = right;
		} else if ((rSourceType == SourceType.PULL_STREAM_SERVICE
				|| rSourceType == SourceType.UDP_SOURCE 
				|| rSourceType == SourceType.PUSH_STREAM_SERVICE)
				&& (lSourceType == SourceType.RELATIONAL || lSourceType == SourceType.WSDAIR)) {
			//returnSourceType = lSourceType;
			returnOperator = left;
		} else {
			String message = "Untested scenario: left=" + lSourceType + " right=" + rSourceType;
			logger.warn(message);
			throw new SNEECompilerException(message);
		}
		if (logger.isTraceEnabled()) {
			logger.trace("RETURN getHigherPrecedenceOp() with " + returnOperator);
		}
		return returnOperator;
	}

	
	public double getSourceRate() {		
		return this.sourceRate;
	}
	
	/**
	 * This method sets the source rate 
	 * for the operator
	 * 
	 * @param rate
	 */
	public void setSourceRate(double rate) {
		this.sourceRate = rate;
	}
	
	/**
	 * This method compares the left and right operator based on its source type
	 * and returns the rate based on the precedence Pushed>pulled>Scanned
	 * @param left
	 * @param right
	 * @return
	 * @throws SNEECompilerException 
	 */
	public double getSourceRate(LogicalOperator left, LogicalOperator right) 
	throws SNEECompilerException {
		double returnSourceRate = 1.0;
		returnSourceRate = getHigherPrecedenceOp(left, right).getSourceRate();
		return returnSourceRate;
	}
	
	/**
	 * @param isPullModeOperator the isPullModeOperator to set
	 */
	public void setGetDataByPullModeOperator(boolean isPullModeOperator) {
		this.isGetDataByPullModeOperator = isPullModeOperator;
	}

	/**
	 * @return the isPullModeOperator
	 */
	public boolean isGetDataByPullModeOperator() {
		return isGetDataByPullModeOperator;
	}
	
	/**
	 * @param isPushBasedOperator the isPushBasedOperator to set
	 */
	public void setPushBasedOperator(boolean isPushBasedOperator) {
		this.isPushBasedOperator = isPushBasedOperator;
	}

	/**
	 * @return the isPushBasedOperator
	 */
	public boolean isPushBasedOperator() {
		return isPushBasedOperator;
	}

}

